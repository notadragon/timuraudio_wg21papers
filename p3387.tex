\input{wg21common}

% Footnotes at bottom of page:
 \usepackage[bottom]{footmisc} 

% Table going across a page: 
 \usepackage{longtable}

 % Start sections at 0
% \setcounter{section}{-1}

% color boxes
\usepackage{tikz,lipsum,lmodern}
\usepackage[most]{tcolorbox}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%TABLE OF CONTENTS SETTINGS

\usepackage{titlesec}
\usepackage{tocloft}

% Custom ToC layout because the default sucks
\cftsetindents{section}{0in}{0.24in}
\cftsetindents{subsection}{0.24in}{0.34in}
\cftsetindents{subsubsection}{0.58in}{0.44in}

% Needed later to reduce the ToC depth mid document
\newcommand{\changelocaltocdepth}[1]{%
  \addtocontents{toc}{\protect\setcounter{tocdepth}{#1}}%
  \setcounter{tocdepth}{#1}%
}

\setcounter{tocdepth}{3}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\begin{document}
\title{Contract assertions on coroutines}
\author{
% TODO: commented-out authors have not yet confirmed whether they're willing to co-author
%Andrzej Krzemie\' nski \small(\href{mailto:akrzemi@gmail.com}{akrzemi@gmail.com}) \\
%Iain Sandoe \small(\href{mailto:iain@sandoe.co.uk}{iain@sandoe.co.uk}) \\
%Gor Nishanov \small(\href{mailto:gorn@microsoft.com}{gorn@microsoft.com}) \\
Timur Doumler \small(\href{mailto:papers@timur.audio}{papers@timur.audio}) \\
Peter Bindels \small(\href{mailto:dascandy@gmail.com}{dascandy@gmail.com}) \\
Joshua Berne \small(\href{mailto:jberne4@bloomberg.net}{jberne4@bloomberg.net}) 
}
\date{}
\maketitle

\begin{tabular}{ll}
Document \#: & D3327R0 \\
Date: &2024-09-13 \\
Project: & Programming Language C++ \\
Audience: & SG21, EWG
\end{tabular}

\begin{abstract}
In this paper, we explore the design space for an extension to the Contracts MVP proposal \cite{P2900R8} that allows placing function contract assertions --- \tcode{pre} and 
\tcode{post} --- on coroutines. We discuss the questions that any such proposal must answer, such as the point of evaluation of \tcode{pre} and \tcode{post} on a coroutine and the treatment of coroutine parameters in the predicate of \tcode{post}. We analyse the available solution space, formulate our design goals, and propose the solution that best satisfies those design goals, taking into account the fundamental design principles of both coroutines and Contracts.
\end{abstract}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\tableofcontents*

%\section*{Revision history}

%Revision 0 (2024-04-16)
%\begin{itemize}
%\item Original version
%\end{itemize}

%\pagebreak

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\section{Motivation}
\label{intro}

The current Contracts MVP proposal \cite{P2900R8} makes it ill-formed for a function \tcode{f} to have function contract assertions --- \tcode{pre} and \tcode{post} --- if \tcode{f} is a coroutine; it merely allows \tcode{contract_assert} inside the body of \tcode{f}. This is in many ways unfortunate. As \cite{P3173R0} points out, coroutines are a foundational facility of modern C++ and thus a Contracts proposal should adequately address uses of contract assertions in combination with coroutines.

It has been argued that coroutines are complex and that therefore, their interaction with Contracts is not straightforward and supporting \tcode{pre} and \tcode{post} on coroutines should be delayed post-MVP. The goal of this paper is to resolve the confusion. Hampering the ability to apply \tcode{pre} and \tcode{post} to coroutines does not achieve that; we should not give users more reasons to avoid coroutines.

The fundamental design principle of coroutines is that whether \tcode{f} is a coroutine is an implementation detail that is not known at the declaration of \tcode{f}, or to the caller of \tcode{f}. This design principle can and should be applied to Contracts as well. If a Contracts proposal introduces new ways in which coroutines are different from other functions --- such as disallowing the usage of \tcode{pre} and \tcode{post} on them --- then such a design is in contradiction with how coroutines are designed and specified in C++ today. Ideally, coroutines should work exactly the same as other functions with respect to Contracts.

In a way, this is the only plausible design, and as such, the current restriction in \cite{P2900R8} that \tcode{pre} and \tcode{post} cannot be applied to a coroutine seems arbitrary. Any function \tcode{f} that is a coroutine to which one would like to apply \tcode{pre} and \tcode{post} can be indirected through a single other function \tcode{g} which is not a coroutine, and any \tcode{pre} and \tcode{post} the user wishes to apply to \tcode{f} can instead be applied to \tcode{g}:
\begin{codeblock}
auto g()  // not a coroutine
  pre (/*...*/) 
  post (r: /*...*/) 
{ 
  return f();  // a coroutine
} 
\end{codeblock}
Given the existence of this workaround, it seems reasonable to provide the ability to place \tcode{pre} and \tcode{post} on \tcode{f} directly, and to specify them to behave exactly the same on \tcode{f} as they would today on the wrapper function \tcode{g}. However, as with any other attempt to wrap a function in C++, once additional parameters are being passed there are subtle yet important differences in behavior that must be considered.

In \cite{P2900R8}, in order to odr-use a function parameter in the predicate of \tcode{post}, it has to be declared \tcode{const} on every declaration of the function, so that we can reason about the parameter value not having been modified before \tcode{post} is evaluated. However, in a coroutine, function parameters are effectively always non-\tcode{const} objects, and may be moved from by the implementation, even if they are declared \tcode{const} by the user.

The question therefore arises whether \tcode{post} on a coroutine should see the original parameter objects (which may have moved-from values despite the parameters being declared \tcode{const} by the user), or the parameter copies created by the implementation for the coroutine state (which the original values will have been moved to), or whether something else should happen.

Note that in the non-coroutine wrapper \tcode{g}, this question cannot arise, because if a function parameter of a user-defined non-coroutine function such as \tcode{g} is declared \tcode{const} on every declaration of \tcode{g}, it cannot be moved from or otherwise modified in the implementation of \tcode{g}; any an attempt to do so would be undefined behaviour as per \href{https://eel.is/c++draft/dcl.type.cv#4.sentence-1}{[dcl.type.cv]/4}.

In this paper, we will discuss this particular question in more detail and propose a solution that is consistent with the fundamental design principles of both coroutines and Contracts.

\section{Prior work}

The C++2a Contracts proposal \cite{P0542R5} did not take coroutines into account because they were not yet part of the C++ Standard at the time.

Post-C++20, SG21 decided to not support \tcode{pre} and \tcode{post} on coroutines in the Contracts MVP proposal ``until we have a more complete picture of what we intend to provide'' (see \cite{P2932R3}).

Later, \cite{P2957R0} proposed to add support for \tcode{pre} and \tcode{post} on coroutines. This paper was seen by SG21 in Kona (November 2022). The proposed solution was rejected due to uncertainty on how \tcode{pre} and \tcode{post} should interact with coroutines and whether making them apply to the ramp function, as proposed in the paper, was the correct design direction.

In \cite{P3173R0}, seen by EWG in Tokyo (February 2023), support for \tcode{pre} and \tcode{post} on coroutines was named by a major compiler vendor as one of the criteria for the viability of a Contracts MVP proposal.

Subsequently, it was proposed in \cite{P2957R1} and in \cite{P3251R0} that we should allow \tcode{pre} on coroutines, and make it apply to the ramp function, but not allow \tcode{post}, as a possible way to handle the property of a coroutine that it may move from its function parameters even if they are declared \tcode{const} by the user. Neither paper has yet been seen by SG21 at the time of writing.

This paper incorporates some material from \cite{P3251R0}. It also builds on \cite{P2957R1} and has significant overlap with it, but approaches the problem with a design goal-driven approach and seeks to provide a more exhaustive analysis of the available solution space. 
% TODO: merge P2957R1 into this paper if the authors agree, and rephrase this paragraph

\section{Discussion}

\subsection{Coroutine-ness is an implementation detail}
\label{impldetail}

As we established in Section \ref{intro}, the fundamental design principle behind C++ coroutines, which any Contracts proposal must respect, is that the coroutine-ness of a function \tcode{f} is an implementation detail.

For example, assuming that \tcode{generator<T>} is a conforming promise type (\href{https://eel.is/c++draft/dcl.fct.def.coroutine}{[dcl.fct.def.coroutine]}), given a function declaration 
\begin{codeblock}
generator<int> iota(int n); 
\end{codeblock}
it is impossible to tell if \tcode{iota} is a coroutine implemented as follows:
\begin{codeblock}
generator<int> iota(int n) {
  while (true)
    co_yield n++;
}
\end{codeblock}
or whether \tcode{iota} is a non-coroutine function wrapping a coroutine \tcode{iota_coro_impl} as follows:
\begin{codeblock}
generator<int> iota(int n) {
  return iota_coro_impl(n);
}
\end{codeblock}
or whether no coroutines are involved at all, and \tcode{iota} is a non-coroutine function that manually initialises an object of type \tcode{generator<int>} and returns it, without using any of the C++ coroutine machinery. In all of the above cases, \tcode{pre} and \tcode{post} on the function declaration of \tcode{iota} should mean the same thing and have the same behaviour.

\subsection{The interface of a coroutine}

The full interface of a coroutine consists of two parts. First, there is the coroutine function interface, which is exposed to the caller through the function declaration. This interface covers the initial function call and the returned state at the point of first suspension. From the caller's perspective, the function call behaves like a factory function that creates a coroutine return object; current implementations call this factory function a \emph{ramp function}.

In addition, the coroutine has an extended interface, which covers the additional resume and suspend points of the coroutine and is implemented in the coroutine body and the promise type.  Through this extended interface, one can repeatedly yield values via \tcode{co_yield}, await such values via \tcode{co_await}, and return a final value via \tcode{co_return}.

From the design principle that coroutine-ness is an implementation detail it follows directly that the function contract assertions --- \tcode{pre} and \tcode{post} --- on a coroutine declaration must specify the contract of the function interface, i.e. the ramp function, as this is the only part of the interface known at the site of the function call (which sees only the declaration, not the implementation).

One of the design principles of the Contracts MVP (\cite{P2900R8}, Section 3.1, Design Principle 11) is that \tcode{pre} and \tcode{post} serve both caller and callee. In this case, the callee is the compiler-generated body of the ramp function (see \href{https://eel.is/c++draft/dcl.fct.def.coroutine#5}{[dcl.fct.def.coroutine]/5}): \tcode{pre} on a coroutine is an assertion on the parameters passed into the ramp function when it is called, \emph{before} the coroutine state is constructed, and the state of the program at that point; \tcode{post} on a coroutine is an assertion on the object that the ramp function returns to the caller at the point of first suspension, and the state of the program at that point.

Crucially, the callee of \tcode{pre} and \tcode{post} on the coroutine declaration is \emph{not} the coroutine body --- the function body that the user wrote --- and \tcode{pre} and \tcode{post} on the coroutine declaration do not assert anything directly related to that body. The coroutine body may run on another thread, resume long after the postconditions that apply to the declaration are checked, or even finish before then.\footnote{The coroutine state can be destroyed on initial suspend, which happens before \tcode{post} is checked.} Furthermore, the coroutine body never directly sees the object being returned from the function.

This lack of a direct connection between function declaration and function body may seem strange and unintuitive to users not familiar with coroutines; but it is a fundamental part of their design. Adding \tcode{pre} and \tcode{post} to the function declaration does not change this design and does not make things any more complex than they already are.

In addition to contract assertions on the function interface, one might want to add contract assertions to the extended coroutine interface to specify preconditions and postconditions on its suspension and resumption, i.e. assertions on the values yielded from the coroutine and the state of the program at the suspend and resume points. However, since it is not visible on the function declaration whether a function is a coroutine, contract assertions on this extended interface cannot be specified on the function declaration, at least not without modifying the design of coroutines (which we do not contemplate in this paper).

We can, of course, consider a novel language feature to express such assertions, as a hypothetical post-MVP extension to Contracts. But many use cases for such assertions can already be accomplished with the existing functionality in \cite{P2900R8} by using \tcode{contract_assert} inside the coroutine body or, for contracts that hold for any entity that uses a given promise type, by applying \tcode{pre} and/or \tcode{post} to the various callback functions in that promise type. This latter approach is described in more detail in \cite{P3251R0}. For the remainder of this paper, we focus solely on the coroutine function interface.

\subsection{Point of evaluation of \tcode{pre} and \tcode{post}}

As pointed out in \cite{P2957R1}, correctly specifying the point of evaluation of \tcode{pre} and \tcode{post} needs some slight clarifications for coroutines, however, according to the mental model described in the previous section, this does not conceptually change the point of evaluation itself or compromise the equivalence between coroutines and non-coroutine functions.

\cite{P2900R8} specifies that the precondition assertions are evaluated ``immediately after function parameters are initialised and before entering the function body''. For a coroutine, by ``function body'', we do \emph{not} mean the coroutine body that the user wrote, but the body of the ramp function that the compiler generated. Therefore, the precondition assertions of a coroutine are evaluated \emph{before} any of the coroutine-specific events that happen in the ramp function, such as creating a copy of the parameters, allocating the coroutine state, initialising the promise object, etc.

\cite{P2900R8} further specifies that the postcondition assertions are evaluated ``after the return value has been initialised and local automatic variables have been destroyed but prior to the destruction of function parameters''. Again, for a coroutine, this specification should be applied to the body of the ramp function and not the coroutine body, meaning that the ``return value'' is that of the ramp function (and not any values yielded by the coroutine), and its type is the declared return type of the coroutine; and likewise, the ``local variables'' are those created by the ramp function (and \emph{not} the local variables in the coroutine body).

\subsection{odr-using parameters in \tcode{post}}
\label{paramsinpost}

There is one implementation detail of coroutines that is unobservable caller-side today, but has a possible interaction with postcondition assertions and must therefore be considered by any proposal that might allow the latter on coroutines.

A coroutine behaves as if its body was rewritten by the compiler as defined by \href{https://eel.is/c++draft/dcl.fct.def.coroutine#5}{[dcl.fct.def.coroutine]/5}; this compiler-generated function body is called the ramp function.

When this ramp function is invoked, after initialising the function parameters (and checking the precondition assertions, if we allow them), a copy of each parameter is created for the coroutine state, and the value of each parameter is moved into that copy (\href{https://eel.is/c++draft/dcl.fct.def.coroutine#13}{[dcl.fct.def.coroutine]/13}), potentially leaving the original parameter object in a moved-from state. This is necessary to make the parameters accessible inside the coroutine body, whose lifetime can extend far beyond the ramp function returning.

Notably, this moving-from a parameter happens even if that parameter is declared \tcode{const} by the user: the ramp function removes the top-level \tcode{const} from the parameter, and then modifies that parameter by using it to move-construct the copy. In other words, in a coroutine, a parameter object is never actually \tcode{const}, even if declared \tcode{const} in the function declaration.

This specification may seem strange, but does not cause issues in C++ today because the moved-from parameter values are not exposed to the user in any way. Upon deeper inspection, it turns out that it is actually fully consistent with the design principle that coroutine-ness is an implementation detail. Consider the following declaration of a function \tcode{f}:
\begin{codeblock}
awaitable<int> f(const Widget w);
\end{codeblock}
This function has an awaitable return type, meaning that it could be implemented a a coroutine or as a non-coroutine.

Note that according to \href{https://eel.is/c++draft/dcl.fct#4.sentence-2}{[dcl.fct]/4}, the following declaration declares the exact same function as the previous one:
\begin{codeblock}
awaitable<int> f(Widget w);
\end{codeblock}
Note further that while the function \tcode{f} has the same type in both declarations, the function parameter \tcode{w} does not: it is \tcode{const} in the first declaration, but non-\tcode{const} in the second.

Now, as an implementation detail, the user could choose to provide a non-coroutine definition of \tcode{f} where \tcode{w} is non-\tcode{const}, even if the first declaration of \tcode{f} declares it as \tcode{const}, and modify \tcode{w} inside that definition:
\begin{codeblock}
// f.h
awaitable<int> f(const Widget w);

// f.cpp
awaitable<int> f(Widget w) {
  Widget w_copy = std::move(w); // OK
  // some other code; not a coroutine
}
\end{codeblock}
In this scenario, with the specification in \cite{P2900R8}, one would not be able to odr-use \tcode{w} in the predicate of a \tcode{post} that applies to \tcode{f}, because for that to work, \tcode{w} needs to be declared \tcode{const} on \emph{all} declarations of \tcode{f}.

Now, if the user instead chooses to provide a definition of \tcode{f} that makes \tcode{f} a coroutine, then the implementation of \tcode{f} will not actually be the function body that the user wrote, instead the implementation of \tcode{f} will be the compiler-generated ramp function (which is composed of different bits from the coroutine body, the promise type, etc.), which \emph{implicitly} makes the parameter non-\tcode{const}. However, it might still be declared \tcode{const} on all declarations of \tcode{f} that the user wrote, raising the question how \tcode{post} should behave if such a parameter is odr-used in its predicate. Any viable Contracts proposal needs to handle this situation in a consistent and user-friendly way.

\subsection{The solution space}
\label{solutions}

We are aware of the following potential solutions for how \tcode{pre} and \tcode{post} should behave on a coroutine, all of which have been formally or informally proposed by a WG21 member at some point:
\begin{enumerate}
\item Do not allow \tcode{pre} or \tcode{post} on coroutines at all (status quo in \cite{P2900R8});
\item Allow \tcode{pre} on coroutines, but not \tcode{post} (first proposed in \cite{P2957R1});
\item Allow \tcode{post} on coroutines, but do not allow odr-using parameters in its predicate (first mentioned in \cite{P2957R1} as an alternative);
\item Allow odr-using parameters in the predicate of \tcode{post}; an \emph{id-expression} naming a parameter refers to the copy made for the coroutine state;
\item Allow odr-using parameters in the predicate of \tcode{post}; an \emph{id-expression} naming a parameter refers to the original object, and:
\begin{enumerate}[label=\alph*.,ref=\theenumi\alph*]
        \item the parameter copy made in the ramp function is copy-constructed instead of move-constructed;
        \item is ill-formed if the parameter type has a non-trivial move constructor (i.e., the parameter can have a moved-from value);
        \item no further provision is added, i.e. the \emph{id-expression} may refer to a moved-from value, even if the parameter is declared \tcode{const} by the user (first proposed in \cite{P2957R0}).
\end{enumerate}
\end{enumerate}
All of the above solutions handle the question of odr-using parameters in \tcode{post} in different ways. In order to choose the correct solution, we need to formulate our design goals and determine which of these solutions best satisfies these design goals. This analysis is performed in the following section.

\section{Design goals}

\subsection{Allow \tcode{pre} and \tcode{post} on coroutines}

The simplest and most practical design goal of this proposal is to allow applying \tcode{pre} and \tcode{post} to coroutines in some form. This allows us to specify contract assertions on the parameters passed into the coroutine when it is called, assertions on the object that this function call returns to the caller at the point of first suspension, as well as assertions on other aspects of the state of the program at those points.

Such assertions can be useful for the same reasons that assertions on any other function can be useful: they allow enhancing the program with configurable checks of its correctness, thereby helping to diagnose and fix program defects.

Solution 1 does not allow either \tcode{pre} or \tcode{post} on coroutines, while Solution 2 does not allow \tcode{post}; all other solutions satisfy this design goal in some form.

\subsection{Treat coroutine-ness as an implementation detail}
\label{goal_coro_principle}

As we already discussed multiple times in this paper, the fundamental design principle of coroutines is that whether \tcode{f} is a coroutine is an implementation detail that is not known at the declaration of \tcode{f}, or at a call to \tcode{f}. Any solution should be consistent with this design principle.

Solutions 1 and 2 violate this principle because they make \tcode{pre} and/or \tcode{post} ill-formed on the declaration of a function depending on whether the function is a coroutine. So does Solution 5b, with the only difference that \tcode{post} is ill-formed only for certain types. 

Solutions 4 and 5c also violate this principle. Although they do not make \tcode{pre} and/or \tcode{post} ill-formed for a coroutine, they expose coroutine-specific implementation details to the caller, such as objects internal to the coroutine state (Solution 4) and the moved-from values of the original parameter objects (Solution 5c).

Whether Solution 3 satisfies this principle seems questionable at first. On the one hand, one can argue that it violates the principle because it makes odr-using a \tcode{const} parameter ill-formed if the function is implemented as a coroutine, and therefore makes that implementation detail observable. On the other hand, there is actually nothing coroutine-specific about it: as discussed in Section \ref{paramsinpost}, any non-coroutine function that has a parameter declared \tcode{const} on its declaration could have an implementation where the same parameter is not declared \tcode{const}, rendering that same \tcode{post} on the declaration ill-formed with \cite{P2900R8} today.

Therefore, making a parameter that is declared \tcode{const} on the declaration non-\tcode{const} in the definition is indeed an implementation detail that is observable in \tcode{post}, but that is already the case with the specification of \cite{P2900R8} today,\footnote{Note that with \cite{P2900R8} as specified today, if the compiler sees any declaration of a function \tcode{f}, which includes any definition of \tcode{f}, where a given parameter is not \tcode{const}, in any translation unit, it already must diagnose any \tcode{post} on \tcode{f} that odr-uses that parameter in its predicate as ill-formed, even if that \tcode{post} is on another declaration of \tcode{f} in another translation unit and that declaration declares the parameter as \tcode{const}. Solution 3 therefore does not add any additional implementation burden.} and can happen irrespective of whether the function is a coroutine or not. Solution 3 therefore does not expose the coroutine-ness as such to the caller; it merely acknowledges that making a function a coroutine is one of the possible implementations that make a parameter non-\tcode{const}. The litmus test here is whether Solution 3 would give us a way to detect at the call site of a function whether that function is a coroutine. Solutions 1, 2, 4, and 5c would do this; Solution 3 would not. We therefore conclude that Solution 3 does not violate the principle that coroutine-ness is an implementation detail.

\subsection{Do not expose moved-from parameters in \tcode{post}}

On the one hand, exposing the moved-from parameter value in \tcode{post} is the ``honest'' choice, as it simply reflects what is going on under the hood. On the other hand, it exposes an implementation detail of C++ coroutines to the caller that is currently not being exposed. Apart from violating the fundamental design principle of coroutines (see previous section), observing such moved-from values when odr-using \tcode{const} parameters is likely to be surprising to the user, and can lead to unexpected behaviour and unintended bugs that will be very difficult to diagnose and fix. It should therefore be a design goal to avoid this, guided by an underlying design principle that Contracts and coroutines should not be unnecessarily user-hostile.

Furthermore, it does not seem useful to be able to write a postcondition on a parameter that can be moved-from, as we cannot reason about the meaning of such a postcondition, in the same way in which we cannot reason about the meaning of a postcondition on a parameter that is not declared \tcode{const} (which is the reason why \cite{P2900R8} makes such postcondition assertions ill-formed). Overall, it is therefore a reasonable design goal to avoid this scenario. Solution 5c directly violates this design goal.
%JMB: 5b violates it too, and relies on what is often not considered a semantic change in a type to decide that it "works" anyway.   Even if there's no move constructor, you are still unquestionably using an object that has been moved-from as a non-const xvalue to initialize another object, and not consistently applying the rule that we don't we the value of such objects is confusing.

%TD: I don't agree with this characterisation. If your type doesn't have a non-trivial move constructor, there is literally no way to "move-from" an object of this type, as this operation does not exist for this type, so moved-from values cannot exist either. Note that `int i = 42; int j = std::move(i);` is exactly equivalent to `int i = 42; int j = i;` and it is guaranteed by the Standard that it is exactly equivalent. Same for non-trivial types that have a user-provided copy constructor but no move constructor: the Standard guarantees that when you try to move-from, what actually happens is a normal copy. So I don't see how 5b violates this design goal, and I don't see how your statement "you are still unquestionably using an object that has been moved-from" can be true for those types.

%JMB: The fact that a trivially moveable thign leaves its moved-from object in an empty state is just the result of an optimization --- it's still moved-from.   `int` might promise not to change the source when doing a move, but my type that happens to be trivially movable today shouldn't ever be beholden to that promise going forward just becuase a memcpy suffices today.
% If I write this code:
%   void f(T t)
%   {
%       g(std::move(t));
%       h(std::move(t));
%   }
% Your response should be "that's broken", not "that's OK if T happens to be trivially movable".
%
% THis is the same thing.

% TD: I think this is a purely philosophical debate. My reply to your code above is indeed "that's OK if T happens to be trivially movable" because that's just what falls out of the current specification. I suggest we don't spend more time on this here as whether or not 5b gets a green mark or a red cross in this row is pretty much irrelevant, because we are already discarding 5b as a viable solution due to it violating the "do not facilitate remote code breakage" design goal. Are you OK with leaving this discussion be for now, in the interest of getting the paper out sooner?

% JMB: I still think we need to mention something --- especially since solution 5b isn't just trivial moves but also moves that degrade to copies (whichi might modify mutable members of the source).  How about something like "Solution 5b violates this goal in principle, although it limits use of move operations to those types where the source is known to be unmodified or which are totally move-unaware."

\subsection{Satisfy the Contracts Prime Directive}
\label{goal_prime_directive}

The most fundamendal design principle of the Contracts MVP, the so-called Contracts Prime Directive (\cite{P2900R8}, Section 3.1, Principle 1) states that adding \tcode{pre} or \tcode{post} to an existing program should not alter the correctness of that program, as this would undermine the purpose of contract assertions --- instead of checking the correctness of the program the user wrote, they would check the correctness of some other program, potentially leading to so-called ``Heisenbugs'' as well as other problems.

A corollary of this fundamental principle is that adding \tcode{pre} or \tcode{post} to an existing program should not change the compile-time or run-time semantics of that program (see \cite{P2900R8}, Section 3.1, Principles 2 and 3).

Solution 4 violates this principle. While making parameters in \tcode{post} refer to the parameter copy that is part of the coroutine state seems implementable, it will require changes to the semantics of the coroutine, such as extending its lifetime (otherwise, the coroutine state may be destroyed during initial suspend, i.e. before \tcode{post} is checked, and the parameter object along with it). Without making changes to the coroutine semantics, there would be no point at which the parameter copies and the return value necessarily exist at the same time, and therefore no point at which \tcode{post} could be checked.

Solution 5a violates this principle as well, as adding \tcode{post} to a coroutine would incur an additional copy, even if the \emph{ignore} semantic is used and predicate is never checked. For the same reason, we made it ill-formed in \cite{P2900R8} for a contract assertion to trigger an implicit lambda capture.

\subsection{Do not introduce additional inconsistencies between \tcode{pre} and \tcode{post}}

A well-designed Contracts feature will naturally compose with other C++ language features, including coroutines. We should avoid adding more complexity to make Contracts and coroutines work together. In particular, we should avoid introducing new inconsistencies between \tcode{pre} and \tcode{post} that do not exist in the current design, as that could be surprising to the user and hinder effective usage and wider adoption of Contracts.

Arguably, Solution 2 violates this design goal, because being able to apply \tcode{pre}, but not \tcode{post} to a function would be a new inconsistency and arguably surprising.

Solution 4 also violates this design goal. Currently, if a function has a \tcode{pre} and a \tcode{post}, and their predicates odr-use the same function parameter, then the corresponding \emph{id-expression} will refer to the same parameter object with the same address. Solution 4 breaks this symmetry, which will be unexpected to most users.

Finally, Solution 5c violates this design goal as well. Currently, if a function has a \tcode{pre} and a \tcode{post}, and their predicates odr-use the same function parameter, that parameter must be \tcode{const} and therefore \tcode{pre} and \tcode{post} are guaranteed to see the same value for that parameter (at least, if the parameter type has been implemented with \tcode{const}-correctness). Solution 4 however would lead to potentially different values being observed in \tcode{pre} and \tcode{post}, respectively.

Note that Solution 3 does not violate this design goal because it does not introduce a new inconsistency. As already discussed above, one of the necessary limitations of \tcode{post}, compared to \tcode{pre}, is that it is ill-formed to odr-use non-\tcode{const} parameters in the predicate of \tcode{post}. However, the parameters of a coroutine are never \tcode{const}, even if declared \tcode{const} by the user. Therefore, implementing a function as a coroutine is just another way of making a non-reference parameter non-\tcode{const}.

\subsection{Do not facilitate remote code breakage}

Our design for how Contracts and coroutines work together should not facilitate situations that can lead to unintended, remote code breakage. Solution 5b violates this design goal because it would create a new dependency between the trivial movability of a type and the ability to use it as a function parameter.

For example, if the user adds a move constructor to a type that previously only had a copy constructor (something that we explicitly encourage people to do to modernise their code!), this will break clients who happen to use this type as a coroutine parameter. Likewise, if there is a struct with an \tcode{int} and a \tcode{float} data member, and the user adds a \tcode{std::string} data member, this will also break clients who happen to use this type as a coroutine parameter. Such breakage would happen for highly non-obvious reasons, does not have a good workaround (at least not until we get postcondition captures as a post-MVP extensions), and therefore seems user-hostile.

\subsection{Support caller-side checking of \tcode{pre} and \tcode{post}}

The Contracts MVP has been designed from the start to accommodate a wide range of implementation strategies and usage scenarios. In particular, it allows implementations to check precondition and postcondition assertions caller-side and/or callee-side, and enables the two translation units involved to make the decision on contract evaluation semantics independently, which has important use cases (\cite{P2751R1}, \cite{P3228R1}, \cite{P3119R1}, \cite{P3267R1}, \cite{P3321R0}).

In particular, if one has deployed a pre-built library with all contracts ignored, and the user of that pre-built library wishes to verify that it is working correctly when used from particular other translation units, enabling caller-side checking of that library's precondition and postcondition assertions can be very useful, for example to validate a new version of such a library before integrating it into the shipping product. In general, any time we cross the boundary between translation units, it is very helpful (and currently intentionally supported by \cite{P2900R8}) to have both sides of that boundary be able to enable contract checks.

However, in order to be able to enable caller-side checking of \tcode{pre} and \tcode{post}, the predicate cannot depend on anything that is not accessible caller-side and only known callee-side. For coroutines in particular, it means that \tcode{post} cannot refer to the copies of parameter objects that belong to the coroutine state. Solution 4 is therefore not compatible with caller-side checking of \tcode{post}, even though it does allow caller-side checking of \tcode{pre}.

Admittedly, we are aware of fewer use cases for caller-side checking of \tcode{post} than for \tcode{pre}. The former seems useful but overall less important to support than the latter. It might also be unimplementable on some platforms.\footnote{Notably, the Microsoft ABI performs argument destruction callee-side, not caller-side. Since postcondition assertions are specified in \cite{P2900R8} to be evaluated before argument destruction happens, they cannot be checked caller-side on this platform without an ABI break.} Whether supporting caller-side checking of \tcode{post} should be considered a design goal therefore depends on the intended use cases; if we strive to enable the widest range of known use cases for Contracts (``design for the multiverse''), then it arguably should be.

\section{Proposed solution}

Having formulated our design goals, we can now construct a decision matrix that visualises which possible solutions in the available design space satisfy which design goals:


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\newcommand{\yes}{\includegraphics[width=4mm]{images/yes.png}}
\newcommand{\no}{\includegraphics[width=4mm]{images/no.png}}
%\vspace{4mm}
\begin{table}[!h]
\begin{tabular}{|p{7.4cm}|p{0.8cm}|p{0.8cm}|p{0.8cm}|p{0.8cm}|p{0.8cm}|p{0.8cm}|p{0.8cm}|}
\hline 
 & $1$ & $2$ & $3$ & $4$ & $5$a & $5$b & $5$c  \\
\hline
Allow \tcode{pre} on coroutines & \no & \yes & \yes & \yes & \yes & \yes & \yes  \\
\hline
Allow \tcode{post} on coroutines  & \no & \no & \yes & \yes & \yes & \yes & \yes  \\
\hline
Treat coroutine-ness as implementation detail  & \no & \no & \yes & \no & \yes & \no & \no  \\
\hline
Do not expose moved-from parameters  & \yes & \yes & \yes & \yes  & \yes & \yes & \no  \\
\hline
Satisfy Contracts Prime Directive & \yes & \yes & \yes & \no & \no & \yes & \yes  \\
\hline
Do not make \tcode{pre} and \tcode{post} more inconsistent & \yes & \no & \yes & \no & \no & \yes & \no \\
\hline
Do not facilitate remote code breakage & \yes & \yes & \yes & \yes & \yes & \no & \yes \\
\hline
Support caller-side checking of \tcode{pre} and \tcode{post} & \yes & \yes & \yes & \no & \yes & \yes & \yes  \\
\hline
\end{tabular}
\vspace{2mm}
\label{table:matrix}
\end{table}

The decision matrix reveals that the correct choice is Solution 3: allow \tcode{pre} and \tcode{post} on coroutines, but make it ill-formed to odr-use a parameter of a coroutine in the predicate \tcode{post} (even if that parameter is declared \tcode{const} by the user). It is the only possible solution that satisfies all our design goals, and furthermore the only possible solution that is compatible with the fundamental design principles of both coroutines (Section~\ref{goal_coro_principle}) and Contracts (Section~\ref{goal_prime_directive}).

Therefore, we propose to adopt Solution 3 for the Contracts MVP. We are convinced that it is the best option for the C++ language and its users. Furthermore, as we will see in Section~\ref{wording}, Solution 3 is also remarkably simple to specify on top of the existing Contracts and coroutines wording, which is another strong hint that it is indeed the most natural and consistent composition of the Contracts and coroutines features.

Note that if the user really must odr-use function parameters in the predicate of \tcode{post}, a workaround exists: one can wrap the coroutine into a non-coroutine wrapper as shown in Section \ref{intro}. With such a wrapper, there is no question as to whether \tcode{post} applies to the original or copy of the parameter, or whether that parameter might have been moved from, as only the original parameter object is visible to the wrapper, and that parameter object is not modifiable. It is then up to the user how to pass that parameter on to the coroutine (e.g., by copy).

The situation will become even simpler once we get postcondition captures \cite{P3098R0} as a post-MVP extension. Postcondition captures will allow the user to explicitly capture parameters when a function is called, by copy or by reference, with a syntax analogous to lambda captures, and use these captured parameters later in the predicate of \tcode{post} when the function returns. This will work even if the parameter in question is non-\tcode{const}. With this post-MVP extension, the need for a wrapper will go away completely.

\section{Proposed wording}
\label{wording}

Our wording strategy for the point of evaluation is to not modify the specification of the point of evaluation of \tcode{pre} and \tcode{post} in \cite{P2900R8} in any way, but instead to clarify that  operations that are specific to the compiler-generated ramp function, in particular creating a copy of the parameters and allocating the coroutine state, are considered part of the function body.

Likewise, our wording strategy for making it ill-formed to odr-use parameters in the predicate of \tcode{post} is to not modify the specification for odr-using parameters in \tcode{post} in \cite{P2900R8} in any way, but instead to clarify that a coroutine effectively removes \tcode{const} from its parameter declarations. This is already implied by the existing wording for the generated ramp function body, but is not specified clearly enough and contains a somewhat misleading note.

With these wording clarifications in [dcl.fct.def.coroutine], none of which are specific to Contracts, both the point of evaluation of \tcode{pre} and \tcode{post} relative to anything that happens in the ramp function and the prohibition to odr-use coroutine parameters in the predicate of \tcode{post} simply follow from the existing, non-coroutine-specific wording in \cite{P2900R8}.

Therefore, to specify our proposed solution, the only necessary modification to the actual Contracts wording in \cite{P2900R8} is the removal of the prohibition  for \tcode{pre} and \tcode{post} to apply to a coroutine.

The proposed wording is relative to \cite{P2900R8}.

Modify [dcl.contract.func], paragraph 6:
\begin{adjustwidth}{0.5cm}{0.5cm}
A \removed{coroutine ([dcl.fct.def.coroutine]), }a deleted function ([dcl.fct.def.delete])\removed{,} or a function defaulted on its first declaration ([dcl.fct.def.default]) may not have a \emph{function-contract-specifier-seq}.
\end{adjustwidth}

Modify [dcl.fct.def.coroutine], paragraph 5:

\begin{adjustwidth}{0.5cm}{0.5cm}
A coroutine behaves as if \added{the top-level $cv$-qualifiers in all \emph{parameter-declaration}s in the declarator of its \grammarterm{function-definition} were removed, and }its \grammarterm{function-body} were replaced by: [...]
\end{adjustwidth}

Modify [dcl.fct.def.coroutine], paragraph 9:
\begin{adjustwidth}{0.5cm}{0.5cm}
An implementation may need to allocate additional storage for a coroutine. This storage is known as the \emph{coroutine state} and is obtained by calling a non-array allocation function ([basic.stc.dynamic.allocation])\added{ as part of the replacement body}. The allocation function's name is looked up by searching for it in the scope of the promise type.
\end{adjustwidth}

Modify [dcl.fct.def.coroutine], paragraph 13:
\begin{adjustwidth}{0.5cm}{0.5cm}
When a coroutine is invoked, \removed{after initializing its parameters ([expr.call])}\added{at the beginning of the replacement body}, a copy is created for each coroutine parameter. For a parameter of type $cv$ \tcode{T}, the copy is a variable of type $cv$ \tcode{T} with automatic storage duration that is direct-initialized from an xvalue of type \tcode{T} referring to the parameter.

\removed{[ \emph{Note:} An original parameter object is never a const or volatile object ([basic.type.qualifier]). --- \emph{end note} ]}
\end{adjustwidth}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%\section*{Acknowledgements}
% TODO 
% - acknowledge Ville for the "caller side checking of pre is more important than post" comment?

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

% Replace ToC entry for bibliography by custom one
%\addtocontents{toc}{\protect\numberline{}} % Blank line in ToC
\addcontentsline{toc}{section}{\protect\numberline{}Bibliography} %Manual ToC entry
\renewcommand{\addcontentsline}[3]{}% Make \addcontentsline a no-op to disable auto ToC entry

%\renewcommand{\bibname}{References}  % custom name for bibliography
\bibliographystyle{abstract}
\bibliography{ref}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\end{document}

