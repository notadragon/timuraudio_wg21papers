\input{wg21common}

% Footnotes at bottom of page:
 \usepackage[bottom]{footmisc} 

% Table going across a page: 
 \usepackage{longtable}

 % Start sections at 0
% \setcounter{section}{-1}

% color boxes
\usepackage{tikz,lipsum,lmodern}
\usepackage[most]{tcolorbox}

% To make Josh's \iref command work here
\renewcommand{\iref}[1]{ ([#1])}

% Indent code that needs to be outside of codeblock because we need green underline
\newcommand{\codetab}[0]{\phantom{\tcode{xx}}}
\newcommand{\codelongtab}[0]{\phantom{\tcode{xxxxxxxx}}}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%TABLE OF CONTENTS SETTINGS

\usepackage{titlesec}
\usepackage{tocloft}

% Custom ToC layout because the default sucks
\cftsetindents{section}{0in}{0.24in}
\cftsetindents{subsection}{0.24in}{0.34in}
\cftsetindents{subsubsection}{0.58in}{0.44in}

% Needed later to reduce the ToC depth mid document
\newcommand{\changelocaltocdepth}[1]{%
  \addtocontents{toc}{\protect\setcounter{tocdepth}{#1}}%
  \setcounter{tocdepth}{#1}%
}

\setcounter{tocdepth}{3}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%POLLS

\definecolor{pollFrame}{rgb}{0,.718,0}
\definecolor{pollBG}{rgb}{.5,1,.5}

\newtcolorbox{wgpoll}[1]{colframe=pollFrame,colback=pollBG!20!white,title={#1}}

\newcommand{\wgpollresult}[5]{%

  \vspace{2mm}
  \begin{tabular}{c | c | c | c | c} %
  SF  & F  & N  & A  & SA \\ %
  \hline %
  #1 & #2 & #3 & #4 & #5 \\ %

  \end{tabular}
  \vspace{2mm}  \\ %
}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\begin{document}
\title{Making erroneous behaviour consistent with Contracts}
\author{
Timur Doumler \small(\href{mailto:papers@timur.audio}{papers@timur.audio}) \\
Joshua Berne \small(\href{mailto:jberne4@bloomberg.net}{jberne4@bloomberg.net}) \\
}
\date{}
\maketitle

\begin{tabular}{ll}
Document \#: & D3329R0 \\
Date: &2025-01-13 \\
Project: & Programming Language C++ \\
Audience: & SG21, EWG, LEWG
\end{tabular}

%JMB: make up your mind as to how you want to spell behavior
\begin{abstract}
This paper proposes the first step towards \cite{P3100R1} --- a unified framework for describing and handling incorrect C++ programs. In this framework, undefined behavior, erroneous behavior, and contract violations are all different aspects of a coherent whole. While most of the changes proposed in \cite{P3100R1} can wait until C++29, this paper contains the part that needs to be adopted for C++26 to avoid setting in stone inconsistencies between the concepts of ``erroneous behaviour'' on the one hand and ``contract violation'' on the other hand that would permanently preclude future evolution towards \cite{P3100R1}.  Not only does this pave the way for a brigher future, we believe it also clarifies the scope of erroneous behaviors already adopted.
\end{abstract}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%\tableofcontents*
%\pagebreak

%\section*{Revision history}

%Revision 0 (2024-04-16)
%\begin{itemize}
%\item Original version
%\end{itemize}

%\pagebreak

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%


\section{Motivation and context}
\label{motivation}

C++ is at an inflection point. To effectively address the safety and security challenges currently facing the C++ ecosystem, a \emph{holistic} strategy is needed.

A key part of this strategy is to introduce to the C++ Standard a unified framework for describing programs that are \emph{incorrect}, i.e. whose source code has a bug, and mitigating such bugs during program execution, without leaving the behaviour undefined. This approach is complementary to introducing \emph{static} language guarantees that make unsafe constructs ill-formed, and targets bugs that cannot be prevented statically.

Such a unified framework is being proposed in \cite{P3100R1}. That proposal is large and the proposed specification is not yet complete; it is thus not in scope for C++26. However, there is a small subset of \cite{P3100R1} that must be applied \emph{before} we ship C++26, otherwise we would be setting in stone inconsistencies that would greatly hinder future evolution towards \cite{P3100R1}. This paper proposes to apply just this part to the C++26 Working Draft.

The issue is that we currently have \emph{two} separate specification tools for describing incorrect programs, both of which are heading towards C++26: \emph{erroneous behaviour} (\cite{P2795R5}; already merged into the C++26 WD) and \emph{contract violations} (\cite{P2900R13}). Both convey the same concept: a program that encounters erroneous behaviour --- or a contract violation --- is known to be defective, yet its behaviour at that point is well-defined. Both offer the implementation essentially the same options for mitigation. In the current C++26 WD, [intro.abstract] reads:
\begin{adjustwidth}{0.5cm}{0.5cm}
If the execution contains an operation specified as having erroneous behaviour, the implementation is permitted to issue a diagnostic and is permitted to terminate the execution at an unspecified time after that operation.
\end{adjustwidth}
%JMB: eh, this is equating "issue a diagnostic" with invoking a user-provided contract-violation handler.   That's a stretch.
Note that issuing a diagnostic and terminating is isomorphic to the \emph{quick-enforce} semantic, while opting to not check and let the program continue as-is is equivalent to the \emph{ignore} semantic.   Other than not being hooked into the contract-violation handler, an expression \tcode{E} that evaluates to an erroneous value is thus essentially equivalent to the following function:

\begin{codeblock}
auto eval_E() 
post (r: !is_erroneous(r) { 
  return E;
}
\end{codeblock}

If we break them down, we can see that the two approaches to handling incorrect programs are very similar in shape and differ primarily in nomenclature:
\begin{itemize}
\item{\emph{Erroneous behavior} identifies behavior that is incorrect (yet well defined) and implies the condition under which that behavior is reached.}
\item{\emph{Contract checking} identifies explicitly the condition where incorrect behavior is identified and leaves unnamed the (possibly well-defined but possibly undefined) behavior that follows a violation}
\end{itemize}
From that, it's clear that any case where you have well-defined behavior after a contract violation what you really have \emph{is} erroneous behavior.  Similarly, any case where you have a condition that identifies erroneous behavior, what you have is a contract assertion on that condition.   The only difference is that erroneous behavior is the well-defined behaviors that follow a contract violation, while contract violations can also be followed by undefined behavior (if \emph{ignored}, \emph{observed}, or \emph{assumed}).

Understanding now that erroneous behavior is a specific category of behavior that might follow a contract violation, we must then consider the concrete differences in the behaviors specified for erroneous in the draft Standard today and how a contract violation followed by matching well-defined behavior would behave:
\begin{itemize}
\item While printing a diagnostic message --- also known as the \emph{default contract-violation handler}\footnote{Strictly speaking, the effects of the default contract-violation handler are implementation-defined, so an implementation could choose to do anything, but the recommended practice in \cite{P2900R13} is that the default contract-violation handler prints a diagnostic message, and we expect this recommended practice to be followed on all major compilers. Note that this behaviour is also backwards-compatible with the default behaviour of the C \tcode{assert} macro.} --- is recommended behaviour for both contract violations and erroneous behaviour, \cite{P2900R13} allows the user to override this behaviour and install their own user-defined contract-violation handler, while erroneous behaviour does not. 

\item When a contract assertion is evaluated with a terminating semantic (\emph{enforce} or \emph{quick-enforce}) and a contract violation has been detected, \cite{P2900R13} specifies exactly which modes of termination are conforming (namely, the three erroneous termination modes available in C++: \tcode{std::terminate}, \tcode{std::abort}, and immediate termination, such as via a trap instruction --- all of which have important use cases), while erroneous behaviour does not.

\item If the program is terminated due to a contract violation, termination happens as part of evaluating the contract assertion and immediately after the violation has been handled; on the other hand, if erroneous behaviour is encountered, termination happens ``at an unspecified time after that operation'', introducing some sort of ``Damocles semantic'' that makes it much harder to reason about the behaviour of the program.  Essentially, with erroneous behavior as specified today, a program effectively enters an ``erroneous state'' once any erroneous behavior happens, and the program may be unceremoniously terminated at any point after that.  The expectation is that it will be either reasonably soon or never, but the specification gives significantly more freedom.

\item If an expression would evaluate an operation that would have erroneous behaviour, it does not qualify as a core constant expression, which in turn allows the user to SFINAE on whether an expression results in erroneous behaviour. On the other hand, if an \emph{enforced} contract assertion fails during constant evaluation, the program is straight up ill-formed. 
\end{itemize}

To remove the above inconsistencies and pave the way towards a unified standard framework for reasoning about incorrect programs, we need to change the terminology and specification of erroneous behaviour to align with Contracts --- \emph{before} shipping erroneous behaviour in C++26.



\section{Proposed design}

\subsection{Implicit contract assertions}

The first  and most important step towards the unified framework proposed in \cite{P3100R1} is to extend the notion of \emph{contract assertion} by distinguishing between \emph{explicit} and \emph{implicit} contract assertions. Explicit contract assertions are those that \cite{P2900R13} proposes. They are added to the program explicitly using function contract specifiers (\tcode{pre}, \tcode{post}) and assertion statements (\mbox{\tcode{contract_assert}}). By contrast, implicit contract assertions are not directly visible in code, but injected into the program by the implementation. Otherwise, explicit and implicit contract assertions behave the same. Importantly, they can be evaluated with the same four evaluation semantics --- \emph{ignore}, \emph{observe}, \emph{enforce}, and \emph{quick-enforce} --- and call the same global contract-violation handler. 

The second step is to recognise that the occurrence of erroneous behaviour --- such as when a builtin operation results in an erroneous value --- is equivalent to the violation of an implicit contract assertion that the operation does \emph{not} result in an erroneous value. We can then remove the notion of erroneous behaviour from the Standard specification entirely and instead say that the evaluation of any builtin operation includes an implicit postcondition assertion that it does not produce an erroneous value. Following \cite{P2900R13}, that implicit postcondition assertion can then be evaluated with any of the four evaluation semantics, a violation can trigger the contract-violation handler, etc. This modification instantly removes all inconsistencies described in Section~\ref{motivation}.

Calling a user-defined contract-violation handler on erroneous behaviour is already existing practice: UBSan, an implementation that detects erroneous behaviour, offers an API\footnote{All Clang sanitisers offer the API \tcode{__sanitizer_set_death_callback} for this purpose; ASan additionally offers a slightly more sophisticated API \tcode{__asan_set_error_report_callback}.} that allows the user to install such a custom handler. As discussed in \cite{P3100R1}, there are many benefits in standardising an API for such callbacks via the replaceable contract-violation handler, and allowing any program defect detected during program execution, including erroneous behaviour, to trigger that same handler.

The same strategy can be applied in the same way to all other cases where the implementation determines at runtime that the program code has a bug. This includes all occurrences of undefined behaviour which \cite{P2795R5}, Section ``The Broader Picture'' lists as a ``candidate for conversion to erroneous behaviour'': signed integer overflow, unrepresentable arithmetic conversions, bad bitshifts, and so on. We make all these operations safe by specifying the appropriate implicit precondition or postcondition assertions and a well-defined fallback behaviour; see \cite{P3100R1}. It also includes implicit contract violations inserted by Profiles; see \cite{P3081R1}.

Note that --- apart from the issue discussed in Section~\ref{damocles} --- the change proposed here is \emph{non-breaking}: a conforming implementation of \cite{P2795R5} will remain conforming with this paper. Note further that while we propose to rephrase erroneous behaviour entirely in terms of implicit contract assertions and thus remove the notion of \emph{erroneous behaviour} from the C++ Standard, the notion of \emph{erroneous value} remains useful, and in fact we propose below that it should be extended in order to more clearly achieve its original goals.

\subsection{Extending the contract-violation handling API}

In order to introduce implicit contract assertions on top of \cite{P2900R13}, we need to extend the contract-violation handling API, which currently only covers explicit contract assertions. Specifically, we need to specify the state of the \mbox{\tcode{std::contracts::contract_violation}} object that a user-defined contract-violation handler will see when such an implicit contract assertion is violated. Only two small extensions to that API are needed. 

The first extension concerns the \tcode{kind()} property of \tcode{contract_violation}, which returns an enum value that represents the syntactic form of the violated contract assertion. In addition to the three enumerators \tcode{pre}, \tcode{post}, and \tcode{assert} from \cite{P2900R13}, which represent explicit precondition assertions, postcondition assertions, and assertion statements, respectively, we propose a fourth enumerator \tcode{implicit}, which represents all forms of implicit contract assertions, including the ones resulting from erroneous values that we propose to introduce here. This is the same enumerator also proposed in \cite{P3100R1} (of which this paper is a subset) and in \cite{P3081R1} (Profiles).

The second extension concerns the \tcode{detection_mode()} property of \tcode{contract_violation}, which returns an enum value that represents the particular failure mode. In addition to the three enumerators \tcode{predicate_false} and \tcode{evaluation_exception} from \cite{P2900R13}, we propose a third enumerator \tcode{erroneous_value}, which represents a contract violation due to an erroneous value being produced. Note that this is distinct from the evaluation of a boolean predicate returning \tcode{false} or exiting via an exception, because the determination that an erroneous value was produced (and therefore a contract violation occurred) takes place in an implementation-defined fashion and not necessarily by evaluating a boolean predicate; therefore, the existing two enumerators do not apply. This is again fully consistent with the direction in \cite{P3100R1} as well as with \cite{P3081R1}, which introduces its own values for \tcode{detection_mode()} for the new failure modes added by Profiles.

The numeric values of the enumerators do not carry any special meaning (see \cite{P3327R0}, Section 3.4 for rationale), so it does not matter very much how we choose them. Here, we propose to make \tcode{assertion_kind::implicit} first in the list (value  \tcode{1}), because implicit contract assertions are the only ones that are \emph{not} introduced by a specifier and thus are distinct from all other kinds of assertions, including kinds we might add post-\cite{P2900R13} such as class invariants and procedural interfaces. However, if a breaking change to \cite{P2900R13} is not desired, we might as well  append it to the list (value \tcode{4}). As for \tcode{detection_mode}, any proposal adding a new detection mode to the Contracts framework simply appends them to the list.

\subsection{Replacing the ``Damocles semantic'' by ``sticky'' erroneous values}
\label{damocles}

We, as a community, are lucky enough to already have implementations that identify and trap on uses of uninitialized values.  The issue, however, is that the implementation of such checks is often done as instrumentation of compiled code, and thus can be a less than direct mapping of reading of C++ expression that does a first uninitialized read to the instructions that can be turned into a diagnostic error of some kind.   In practice, it is not the read of the uninitialized value that is identified but rather the first case where a branch is taken based on that value --- and this can be much later than the actual read.

On the other hand, such implementations will never notice an uninitialized read and then set a timer, wait an arbitrary time, and terminate the program while it is doing something completely unrelated.  The specification of erroneous behavior today allows this choice unnecessarily.

To fix this, we propose that erroneous values be ``sticky'' in a way that they are not today.  The specification today takes the approach that once you read an erroneous value the value itself is then ``cleaned'' and no longer toxic, but comes with the downside that all following program behavior is now erroneous and thus at risk of termination.    By having erroneous values propagate with the data, however, we can extend the scope of the problematic data sufficiently to cover all realistic implementations while avoiding the more toxic threat of eventual and surprising termination at a later date.

In practice, we don't expect the erroneous of a value to transport beyond a single function or translation unit, but we should still allow for that possibility if an adventurous platform chooses to do so.   Therefore, we simply make any operation whose result is dependent on an erroneous value produce an erroneous value.   A program that discards all such data and moves on is in no threat of unexpected termination, while leaving us maximal flexibility for identifying the bug when it is most convenient to do so.

% TD: Josh, can you write up this subsection? I could try but I think you have a much deeper understanding of how this is supposed to work or why it is necessary
% JMB: I think i did.

\subsection{Interaction with \tcode{noexcept}}

Consider:
\begin{codeblock}
bool f() {
  int x;
  return noexcept(x + 1);
}
\end{codeblock}
In C++ today, calling \tcode{f()} has defined behaviour (the indeterminate value is never accessed; the operand of \tcode{noexcept} is an unevaluated operand) and returns \tcode{true} (adding two integers can never throw an exception unless the behaviour is undefined). If we want to avoid breaking changes to the existing language, the result of the \tcode{noexcept} operator must remain the same with this proposal.

However, since \tcode{x} has an erroneous value, evaluating \tcode{x + 1} may call the contract violation handler, which may throw an exception. With this proposal, it is therefore no longer true that \tcode{x + 1} can never throw an exception unless the behaviour is undefined.

A detailed discussion of this problem can be found in \cite{P3541R1}. The possible solutions broadly fall into three categories: either accept the breaking change to the \tcode{noexcept} operator, or do not allow throwing violation handlers for implicit contract assertions, or redefine the  meaning of the \tcode{noexcept} operator to be ``can never throw an exception \emph{unless there is a contract violation}''. SG21 discussed this problem at great length and in the end achieved consensus that the only acceptable solution is the last one. We follow this decision in this paper.

It is therefore possible for an implicit contract assertion to call a throwing contract-violation handler when violated, and for the evaluation of the expression to exit via that exception, even if the \tcode{noexcept} operator returns \tcode{true} for that expression.

Note that this design is fully consistent with \cite{P3081R1}, which proposes the same behaviour for the implicit contract assertions inserted by Profiles.

\subsection{Constant evaluation}

The change proposed here makes it impossible to SFINAE on whether an expression results in an erroneous value. Such compile-time branching on the presence of a bug should never be allowed; a detailed rationale can be found in \cite{P2900R13} Section 3.1, which enshrines this design principle in the so-called \emph{Contracts Prime Directive}.

In \cite{P2900R13}, when an explicit contract assertion is encountered during constant evaluation, it can be \emph{ignored} --- the predicate is not evaluated at all, \emph{observed} --- if the predicate does not evaluate to \tcode{true}, a diagnostic (warning) is issued, or \emph{enforced} --- if the predicate does not evaluate to \tcode{true}, the program is ill-formed.

For user-authored contract assertions, all three evaluation semantics have important use cases. The \emph{ignore} semantic is useful in code bases where constant evaluation of all contract predicates would have a prohibitively costly impact on compile time; the \emph{observe} semantic is useful when the author is not yet confident about the correctness of the check itself. However, implicit contract assertions do not fall in either category. We can therefore remove the possibility to SFINAE on whether an expression results in an erroneous value while preserving the property of the current C++26 WD that during constant evaluation, an erroneous value can never be produced, by specifying that during constant evaluation, implicit contract assertions can only be evaluated with the \emph{enforce} semantic. In short, with our proposal, if any implicit contract assertions fails during constant evaluation, the program is straight up ill-formed.

\section{Proposed wording}

The wording changes proposed in this section are relative to the C++ Working Draft \cite{N5001} with the changes proposed in \cite{P2900R13} (Contracts) already applied. The proposed changes are also designed to be compatible with \cite{P3081R1} (Profiles).

% TD: TODO: Josh: any wording related to the change in meaning of the noexcept operator is still missing from the paper because I don't know what to do. It looks like wording for this is being drafted on-the-fly by various parties on the reflector. Can you add something reasonable for now, in the appropriate place? Thanks!

Replace ``contract assertion'' with ``explicit contract assertion'' in all places in the wording that do not apply to implicit contract assertions.  This complete list will be reproduced when a core-approved version of the wording in \cite{P2900R13} is available.

Remove [defns.erroneous]:

\begin{adjustwidth}{0.5cm}{0.5cm}
\removed{\textbf{erroneous behavior}}

\removed{well-defined behavior that the implementation is recommended to diagnose}

\removed{[ \emph{Note to entry:} Erroneous behavior is always the consequence of incorrect program code. Implementations are allowed, but not required, to diagnose it ([intro.compliance.general]). Evaluation of a constant expression ([expr.const]) never exhibits behavior specified as erroneous in Clause 4 through Clause 15.--- \emph{end note} ]}
\end{adjustwidth}

Modify [intro.compliance.general], footnote 3:

\begin{adjustwidth}{0.5cm}{0.5cm}
“Correct execution” can include undefined behavior and \removed{erroneous behavior}\added{contract violations ([basic.contract])}, depending on the data being processed; see Clause 3 and [intro.execution].
\end{adjustwidth}

Modify [intro.abstract]:

\begin{adjustwidth}{0.5cm}{0.5cm}
A conforming implementation executing a well-formed program shall produce the same observable behavior as one of the possible executions of the corresponding instance of the abstract machine with the same program and the same input. However, if any such execution contains an undefined operation, this document places no requirement on the implementation executing that program with that input (not even with regard to operations preceding the first undefined operation). \removed{If the execution contains an operation specified as having erroneous behavior, the implementation is permitted to issue a diagnostic and is permitted to terminate the execution at an unspecified time after that operation.}

\removed{\emph{Recommended practice:} An implementation should issue a diagnostic when such an operation is executed.}

\removed{[ \emph{Note:} An implementation can issue a diagnostic if it can determine that erroneous behavior is reachable under an implementation-specific set of assumptions about the program behavior, which can result in false positives. --- \emph{end note} ]}
\end{adjustwidth}

Modify [basic.contract.general] as follows:
\begin{adjustwidth}{0.5cm}{0.5cm}
Contract assertions \removed{allow the programmer to }specify properties of the state of the program that are expected to hold at certain points during execution.

\added{\emph{Explicit} c}\removed{C}ontract assertions are introduced by \emph{precondition-specifier}s, \emph{postcondition-specifier}s ([dcl.contract.func]), and \emph{assertion-statement}s ([stmt.contract.assert]). \added{\emph{Implicit} contract assertions are inserted into the program by the implementation.}

Each contract assertion has a \emph{predicate}, which is an expression of type \tcode{bool}. \removed{[ \emph{Note:} The value of the predicate is used to identify program states that are expected. --- \emph{end notea} ]} \added{If it is determined during program execution that the predicate has a value other than \tcode{true}, a \emph{contract violation} occurs. A contract violation is always the consequence of incorrect program code.}
\end{adjustwidth}

Modify [basic.contract.eval]:

\begin{adjustwidth}{0.5cm}{0.5cm}
An evaluation of a contract assertion uses one of the following four \emph{evaluation semantics}: \emph{ignore}, \emph{observe}, \emph{enforce}, or \emph{quick-enforce}. Observe, enforce, and quick-enforce are checking semantics; enforce and quick-enforce are terminating semantics.

Which evaluation semantic is used for any given evaluation of a contract assertion is implementation-defined. \added{During constant evaluation, an implicit contract assertion is always evaluated with the enforce semantic.} [ \emph{Note:} The evaluation semantics can differ for different evaluations of the same contract assertion, including evaluations during constant evaluation. --- \emph{end note} ]
% TD: Josh: This note looks a bit weird now with the addition before it. Any idea how to improve it?
% JMB: Eh, it doesn't look particularly weird to me.  We could put it in between the two sentences instead, and i think that'd address the weirdness you see, but i think i like that ordering less.

\emph{Recommended practice:} An implementation should provide the option to translate a program such that all evaluations of contract assertions use the ignore semantic as well as the option to translate a program such that all evaluations of \added{explicit} contract assertions use the enforce semantic. By default, evaluations of \added{explicit} contract assertions should use the enforce semantic.
% TD: Josh: That recommended practice also no longer works because we now recommend that the implementation should provide something that we say shall never happen in the previous paragraph. But carving out an exception for implicit contract assertions during constant evaluation right here also seems really ugly. Do you have any better idea?
% JMB: I think just make this about explicit contract assertions.  I don't think we need to invite spending even more time discussing recommended practices.
\end{adjustwidth}

Modify [basic.indet] as follows:

\begin{adjustwidth}{0.5cm}{0.5cm}
When storage for an object with automatic or dynamic storage duration
is obtained,
the bytes comprising the storage for the object
have the following initial value:
\begin{itemize}
\item
If the object has dynamic storage duration, or
is the object associated with a variable or function parameter
whose first declaration is marked with
the \tcode{[[indeterminate]]} attribute\iref{dcl.attr.indet},
the bytes have \emph{indeterminate values};
\item
otherwise, the bytes have \emph{erroneous values},
where each value is determined by the implementation
independently of the state of the program.
\end{itemize}
If no initialization is performed for an object (including subobjects),
such a byte retains its initial value
until that value is replaced\iref{dcl.init.general,expr.ass}.
If any bit in the value representation has an indeterminate value,
the object has an indeterminate value;
otherwise, if any bit in the value representation has an erroneous value,
the object has an erroneous value\iref{conv.lval}.

\begin{note}
Objects with static or thread storage duration are zero-initialized,
see~\iref{basic.start.static}.
\end{note}

%JMB: I don't think we want to try to introduce the assume semantic
%     in this mailing.  If we did, i would change the following slightly
%     to include indeterminate in the new paragraph and take all mention of behaviour
%     out of the following paragraph
%TD: I agree. We don't need the assume semantic here as we wouldn't
%     allow this particular implicit contract assertion to be evaluated with that
%     semantic anyway; you're supposed to use [[indeterminate]] instead.

\begin{addedblock}
The evaluation of any builtin operation includes an implicit postcondition assertion 
that it does not produce an erroneous value.  Except in the following cases,
if any operand of a built-in operator is erroneous then the value
produced by that operator is erroneous:
\begin{itemize}
\item  If the built-in operation is \tcode{*} or \tcode{&} and the other operand is a non-erroneous zero value.
\item  If the built-in operation is \tcode{|} and the other operand is a non-erroneous value whose base-2 representation all of whose coefficients are \tcode{1}.
% do we also allow a-a to be non-erroneous?  nah.
\end{itemize}
\end{addedblock}
%JMB: We might improve the wording later if we don't add to the list, but at the moment this is the list i've got.
%     I'm still mulling over whether we want to allow some form of laundering of erroneous values with
%     byte arrays, but I keep coming down on the side of "no, that's silly, we shouldn't" and so the only thing
%     left is expressions whose result does not depend on the value. 

Except in the following cases,
if an indeterminate value is produced by an evaluation,
the behavior is undefined
 and if an erroneous value is produced by an evaluation
\removed{, the behavior is erroneous and}
the result of the evaluation is the value so produced \removed{but is not erroneous}
\added{and it is erroneous}:

\begin{itemize}
\item
  If an indeterminate or erroneous value of
  unsigned ordinary character type\iref{basic.fundamental}
  or \tcode{std::byte} type\iref{cstddef.syn}
  is produced by the evaluation of:
  \begin{itemize}
  \item
    the second or third operand of a conditional expression\iref{expr.cond},
  \item
    the right operand of a comma expression\iref{expr.comma},
  \item
    the operand of a cast or conversion\iref{conv.integral,
    expr.type.conv,expr.static.cast,expr.cast}
    to an unsigned ordinary character type
    or \tcode{std::byte} type\iref{cstddef.syn}, or
  \item
    a discarded-value expression\iref{expr.context},
  \end{itemize}
  then the result of the operation is an indeterminate value or
  that erroneous value, respectively.
\item
  If an indeterminate or erroneous value of
  unsigned ordinary character type or \tcode{std::byte} type
  is produced by the evaluation of
  the right operand of a simple assignment operator\iref{expr.ass}
  whose first operand is an lvalue of
  unsigned ordinary character type or \tcode{std::byte} type,
  an indeterminate value or that erroneous value, respectively, replaces
  the value of the object referred to by the left operand.
\item
  If an indeterminate or erroneous value of unsigned ordinary character type
  is produced by the evaluation of the initialization expression
  when initializing an object of unsigned ordinary character type,
  that object is initialized to an indeterminate
  value or that erroneous value, respectively.
\item
  If an indeterminate value of
  unsigned ordinary character type or \tcode{std::byte} type
  is produced by the evaluation of the initialization expression
  when initializing an object of \tcode{std::byte} type,
  that object is initialized to an indeterminate value or
  that erroneous value, respectively.
\end{itemize}
Converting an indeterminate or erroneous value of
unsigned ordinary character type or \tcode{std::byte} type
produces an indeterminate or erroneous value, respectively.
In the latter case,
the result of the conversion is the value of the converted operand.

\end{adjustwidth}

Modify [expr.const], paragraph 10:

\begin{adjustwidth}{0.5cm}{0.5cm}
An expression $E$ is a \emph{core constant expression} unless the evaluation of $E$, following the rules of the abstract machine ([intro.abstract]), would evaluate one of the following:
\begin{itemize}
\item [...]
\item an operation that would have undefined \removed{or erroneous }behavior as specified in Clause 4 through Clause 15;
\item [...]
\end{itemize}
\end{adjustwidth}

Modify [dcl.attr.indet], paragraph 3:

\begin{adjustwidth}{0.5cm}{0.5cm}
[ \emph{Note:} Reading from an uninitialized variable that is marked \tcode{[[indeterminate]]} can cause undefined behavior.
\begin{adjustwidth}{0.3cm}{0.3cm}
\tcode{void f(int);}\\
\tcode{void g() \{}\\
\codetab \tcode{int x [[indeterminate]], y;}\\
\codetab \tcode{f(y);} \codelongtab \emph{// \removed{erroneous behavior}\added{contract violation} ([basic.indet])}\\
\codetab \tcode{f(y);} \codelongtab \emph{// undefined behavior}\\
\tcode{\}} \\
\\
\tcode{[...]}
\end{adjustwidth}
--- \emph{end note} ]
\end{adjustwidth}

Modify [nullablepointer.requirements], paragraph 2:

\begin{adjustwidth}{0.5cm}{0.5cm}
A value-initialized object of type \tcode{P} produces the null value of the type. The null value shall be equivalent only to itself. A default-initialized object of type \tcode{P} may have an indeterminate or erroneous value.

\emph{Note:} Operations involving indeterminate values can cause undefined behavior, and operations involving erroneous values can cause \removed{erroneous behavior}\added{contract violations} ([basic.indet]).--- \emph{end note} ]
\end{adjustwidth}

Modify [bit.cast], paragraph 2:

\begin{adjustwidth}{0.5cm}{0.5cm}
For each bit $b$ in the value representation of the result that is indeterminate or erroneous, let $u$ be the smallest object containing that bit enclosing $b$:
\begin{itemize}
\item  If $u$ is of unsigned ordinary character type or \tcode{std::byte} type, $u$ has an indeterminate value if any of the bits in its value representation are indeterminate, or otherwise has an erroneous value.
\item Otherwise, if $b$ is indeterminate, the behavior is undefined.
\item Otherwise, \removed{the behavior is erroneous}\added{an implicit contract violation ([basic.contract]) occurs}, and the result is as specified above.
\end{itemize}
The result does not otherwise contain any indeterminate or erroneous values.
\end{adjustwidth}

Modify [contracts.syn]:

\begin{adjustwidth}{0.5cm}{0.5cm}
\emph{// all freestanding} \\
\tcode{namespace std::contracts \{} \\
\\
\codetab \tcode{enum class assertion_kind : \emph{unspecified}} \\
\codetab \codetab \added{\tcode{implicit = 1,}} \\
\codetab \codetab \tcode{pre = \removed{1}\added{2},} \\
\codetab \codetab \tcode{post = \removed{2}\added{3},} \\
\codetab \codetab \tcode{assert = \removed{3}\added{4}} \\
\codetab \tcode{\};} \\
\\
\codetab \tcode{[...]} \\ 
\\
\codetab \tcode{enum class detection_mode : \emph{unspecified}} \\
\codetab \codetab \tcode{predicate_false = 1,} \\
\codetab \codetab \tcode{evaluation_exception = 2\added{, }} \\
\codetab \codetab \tcode{\added{erroneous_value = 3}} \\
\codetab \tcode{\};} 
\end{adjustwidth}

Modify [support.contracts.enum.kind]:

\begin{adjustwidth}{0.5cm}{0.5cm}
The enumerators of \tcode{assertion_kind} correspond to the possible syntactic forms of a contract assertion ([basic.contract]):
\begin{itemize}
\item \tcode{\added{assertion_kind::implicit}}\added{: the evaluated contract assertion was an implicit contract assertion.}
\item \tcode{assertion_kind::pre}: the evaluated contract assertion was a\added{n explicit} precondition assertion.
\item \tcode{assertion_kind::post}: the evaluated contract assertion was a\added{n explicit} postcondition assertion.
\item \tcode{assertion_kind::assert}: the evaluated contract assertion was an\added{ explicit} assertion-statement.
\end{itemize}
\end{adjustwidth}

Modify [support.contracts.enum.detection]:

\begin{adjustwidth}{0.5cm}{0.5cm}
The enumerators of \tcode{detection_mode} correspond to the manners in which a contract violation ([basic.contract.eval]) can be identified:
\begin{itemize}
\item \tcode{detection_mode::predicate_false}: the contract violation occurred because the predicate evaluated to \tcode{false} or would have evaluated to \tcode{false}.
\item \tcode{detection_mode::evaluation_exception}: the contract violation occurred because the evaluation of the predicate exited via an exception.
\item \tcode{\added{detection_mode::erroneous_value}}\added{: the contract violation occurred because an erro\-neous value was encountered.}
\end{itemize}
\end{adjustwidth}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%\section*{Acknowledgements}
% None so far

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

% Remove ToC entry for bibliography
\renewcommand{\addcontentsline}[3]{}% Make \addcontentsline a no-op to disable auto ToC entry

%\renewcommand{\bibname}{References}  % custom name for bibliography
\bibliographystyle{abstract}
\bibliography{ref}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\end{document}
